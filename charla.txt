
Procesamiento y graficado en tiempo real
========================================
..  (9.5')

Procesamiento en tiempo real
----------------------------

* Cómputos correctos + resultados a tiempo
* ¿A tiempo? Dos tipos básicos:

  - Antes de un deadline
  - Dentro de un margen, ni antes ni después

¿Es posible en python?
----------------------

.. (0.5')

.. image:: images/bebe.jpg
    :scale: 120 %
.. http://www.flickr.com/photos/heldes/364911349/sizes/z/in/photostream/

Sí
--

.. http://www.flickr.com/photos/athoos/265329441/ (CC), http://www.flickr.com/photos/jkonig/3061419305/ (CC)

* Hasta qué punto?

  * Depende **mucho** del contexto. Hay que probarlo!

¿Cómo es posible, python no era lento?
--------------------------------------
.. (1')

Clave: Usar las herramientas adecuadas (KISS)

* *Baja FS*, cálculos simples: *pure python*

* Otro: numpy, pypy, cython, modulo C o C++

* Audio: numpy + PyAudio o PyJack

* Video: OpenCv + numpy

* threading, multiprocessing, Queue, Twisted

.. (Mostrar alguna idea con código, con threading por ejemplo.)

.. * TDCxPM: antigravity + soul

Graficación
-----------
.. (0.5')

- pygame
- pyglet
- matplotlib
- GUIs: canvas, opengl, bitmaps, etc.
- pyqwt
- etc
- **stream_grapher**

stream_grapher
--------------
..  (1')

* Qué es stream_grapher? (http://bitbucket.org/san/stream_grapher)

Un graficador para señales de "tiempo real"

  -  Señales provenientes de

    - serie / COM
    - USB
    - network
    - audio
    - archivos
    - generadas por código

  - Objetivos: Ayudar en el prototipado y desarrollo de hardware,
    filtros digitales y analógicos para medicina, audio, robotica, etc.

¿Cómo surgio?
-------------

.. image:: images/san_exxer.jpeg
    :scale: 75 %


Ejemplo: diseñemos un filtro de audio!
--------------------------------------

Pongamos en la coctelera:

* numpy
* scipy
* jack
* stream_grapher


Diseño: scipy al rescate
------------------------
* Filter design
 
 - remez: Calculate the minimax optimal filter using Remez exchange algorithm.
 - firwin: FIR Filter Design using windowed ideal filter method.
 - iirdesign: Complete IIR digital and analog filter design.
 - iirfilter: IIR digital and analog filter design given order and critical points.
 - freqs: Compute frequency response of analog filter.
 - freqz: Compute frequency response of a digital filter.
 - unique_roots: Determine the unique roots and their multiplicities in two lists
 - residue: Compute partial-fraction expansion of b(s) / a(s).
 - residuez: Compute partial-fraction expansion of b(z) / a(z).
 - invres: Compute b(s) and a(s) from partial fraction expansion: r,p,k
 
* Matlab-style IIR filter design

 - butter (N, Wn[, btype, analog, output]) 	Butterworth digital and analog filter design.
 - buttord (wp, ws, gpass, gstop[, analog]) 	Butterworth filter order selection.
 - cheby1 (N, rp, Wn[, btype, analog, output]) 	Chebyshev type I digital and analog filter design.
 - cheb1ord (wp, ws, gpass, gstop[, analog]) 	Chebyshev type I filter order selection.
 - cheby2 (N, rs, Wn[, btype, analog, output]) 	Chebyshev type I digital and analog filter design.
 - cheb2ord (wp, ws, gpass, gstop[, analog]) 	Chebyshev type II filter order selection.
 - ellip (N, rp, rs, Wn[, btype, analog, output]) 	Elliptic (Cauer) digital and analog filter design.
 - ellipord (wp, ws, gpass, gstop[, analog]) 	Elliptic (Cauer) filter order selection.
 - bessel (N, Wn[, btype, analog, output]) 	Bessel digital and analog filter design.

Ejemplo filtro de audio: Pasabajos
----------------------------------
.. (1')

..  code-block:: python

    class PasaBajos(object):
       def __init__(self):
          FS = 48000.
          BANDPASS, STOPBAND = 1000., 1500.
          wp, ws = BANDPASS/(FS/2), STOPBAND/(FS/2)
          self.b, self.a = iirdesign(wp=wp, ws=ws,
                                     gpass=0.1, 
                                     gstop=40)
          max_len = max(len(self.a), len(self.b))
          self.z0 = numpy.zeros(max_len-1)

       def do_filter(self, data):
          filt_data, self.z0 = lfilter(self.b,
                                       self.a, 
                                       data,
                                       self.z0)
          return filt_data

Gráfico
-------
.. (0.5')

.. image:: images/imagen_filtro.png
    :scale: 100 %

Obtener el audio
----------------
.. (2')

Patron sencillo: thread + main + Queue

Gráfico

thread
------

.. Poner mas codigo de thread, inicializacion?

.. code-block:: python

    # ...
    jack.activate()
    BUFF_SIZE = jack.get_buffer_size()
    input = numpy.zeros((2, BUFF_SIZE), 'f')
    output = numpy.zeros((2, BUFF_SIZE), 'f')

    while True:
        jack.process(output, input)
        input[0] = filtro.do_filter(input[0])
        self.output = self.input.copy()
        graph_queue.put(self.input.copy())

main
----

.. code-block:: python

    # ...
    def get_remaining_samples(self):
        samples = numpy.ndarray(shape=(2,0), 
                                dtype="f")
        while not in_queue.empty():
            samples = numpy.hstack(samples, 
                                   in_queue.get())
        return samples


Showtime!
---------
.. (3')
.. corrida con señal de audio limpia y luego filtrada con un pasabajos 


Conclusiónes
------------
.. ¿?
