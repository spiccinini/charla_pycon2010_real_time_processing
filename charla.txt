Python
======

Qué es Python?
--------------

  - Un lenguaje de programación fácil y potente

  - Interpretado

  - Dinámico

  - Baterías incluídas 

  - Libre y gratis

  - Excelente documentación

NumPy y Scipy
=============

NumPy 
-----

Es un biblioteca de Python que provee el tipo de dato ``array``. Ofrece muchas
funciones útiles y optimizadas para el procesamiento de números.

 - 
SciPy 
-----


Optimización
============

El objetivo es encontrar los valores que mejor ajustan un módelo a ciertas
mediciones realizadas.

En este ejemplo se buscarán 2 características de un transistor ''Mosfet''

Cómo obtuve los datos
---------------------

.. TODO: Agregar alguna foto?

En el laboratorio se miden distintas Id variando Vgs y se obtiene una tabla
como esta::

    #vgs(V) Id(mA)
    1.5     0.04
    1.6     0.11
        ...
    2.2     19.0
        ...
    2.4     42.5
    2.5     72

Definiendo la familia de funciones
----------------------------------

..  code-block:: python

    def id_vgs(vgs, k, vt):
        """ $I_D = k * (V_{GS} - V_T)^2$ """
        return k * (vgs - vt)**2

    def id_vgs_residuo(p, vgs, id_medida):
        """ Residuo para hallar k y vt
            utilizando cuadrados mínimos """
        k, vt = p
        return id_medida - id_vgs(vgs, k, vt)

Leyendo los datos
-----------------

..  code-block:: python

    from numpy import loadtxt, arange

    # Matriz con las mediciones realizadas
    mediciones = loadtxt('id_vgs.txt')

    # Separo en 2 arrays utiles
    vgs, i_d = mediciones[:,0], mediciones[:,1]

Optimizando
-----------

.. code-block:: python

    from scipy.optimize import leastsq

    # Punto desde el que se empieza estimar
    p0 = (100, 1.5)

    k, vt = leastsq(id_vgs_residuo, p0, args=(vgs, i_d))[0]


Mostrando
---------

.. code-block:: python

    from matplotlib import pyplot as plt

    # Grafico los puntos medidos
    plt.plot(vgs, i_d, 'ro-')
    leyenda = ['mediciones']

Mostrando
---------

.. code-block:: python

    from numpy import arange

    # Grafico la función ajustada
    vmax = vgs[-1]
    vs = arange(vt, vmax + 0.2, 0.01)
    plt.plot(vs, id_vgs(vs, k, vt), 'r')
    leyenda.append(u'Función estimada: $k = %.2f'
               '\\frac{mA}{V^2}$, $V_T = %.3f V$' % (k, vt))
    plt.legend(leyenda, loc='upper left')

    # Texto en los ejes
    plt.xlabel('$V_{GS}$ [V]')
    plt.ylabel('$I_D$ [mA]')
    plt.grid()

Resultado
---------

.. image:: images/ajuste.png


Procesamiento y graficado en tiempo real
========================================
..  (9.5')

Procesamiento en tiempo real
----------------------------

* Es posible en python? (0.5')

  - Sí. http://www.flickr.com/photos/heldes/364911349/, http://www.flickr.com/photos/athoos/265329441/ (CC), http://www.flickr.com/photos/jkonig/3061419305/ (CC)

* Hasta qué punto?

  - Depende del contexto. Hay que probarlo!

¿Cómo?
------
.. (1')

Clave: Usar las herramientas adecuadas (KISS)

* _Bajo_ SR, cálculos simples: *pure python*

* Otro: numpy, pypy, cython, modulo C o C++

* Audio: numpy + PyAudio o PyJack

* Video: OpenCv + numpy

* TDCxPM: antigravity + soul

* threading, multiprocessing, Queue, Twisted
  (Mostrar alguna idea con código, con threading por ejemplo.)

Graficación
-----------
.. (0.5')

 - pygame
 - pyglet
 - matplotlib
 - GUI: canvas, opengl, bitmaps, etc.
 - pyqwt
 - etc
 - stream_grapher

stream_grapher
--------------
..  (1')

* Qué es stream_grapher? (http://bitbucket.org/san/stream_grapher)

  - Un graficador para señales de "tiempo real".

    * Provenientes de serie, USB, network, audio, archivos o generadas "programaticamente".

    * Objetivos: Ayudar en el prototipado y desarrollo de hardware,
      filtros digitales y analógicos para medicina, audio, robotica, etc. (2')

  - Cómo surgio? Mostrar foto usandolo en Exxer.

Ejemplo filtro de audio
-----------------------
.. (1')

..  code-block:: python

    class PasaBajos(object):
       def __init__(self):
          FS = 48000.
          BANDPASS, STOPBAND = 1000., 1500.
          wp, ws = BANDPASS/(FS/2), STOPBAND/(FS/2)
          self.b, self.a = iirdesign(wp=wp, ws=ws,
                                     gpass=0.1, 
                                     gstop=40)
          max_len = max(len(self.a), len(self.b))
          self.z0 = numpy.zeros(max_len-1)

       def do_filter(self, data):
          filt_data, self.z0 = lfilter(self.b,
                                       self.a, 
                                       data,
                                       self.z0)
          return filt_data

Gráfico
-------
.. (0.5')

.. image:: images/imagen_filtro.png
    :scale: 70 %

Listado de funciones para diseñar filtros
-----------------------------------------
* a
* b
* c

Obtener el audio
----------------
.. (2')

Patron sencillo: thread + main + Queue

Gráfico

thread
------

.. Poner mas codigo de thread, inicializacion?

.. code-block:: python

    # ...
    jack.activate()
    BUFF_SIZE = jack.get_buffer_size()
    input = numpy.zeros((2, BUFF_SIZE), 'f')
    output = numpy.zeros((2, BUFF_SIZE), 'f')

    while True:
        jack.process(output, input)
        input[0] = filtro.do_filter(input[0])
        self.output = self.input.copy()
        graph_queue.put(self.input.copy())

main
----

.. code-block:: python

    # ...
    def get_remaining_samples(self):
        samples = numpy.ndarray(shape=(2,0), 
                                dtype="f")
        while not in_queue.empty():
            samples = numpy.hstack(samples, 
                                   in_queue.get())
        return samples


Showtime!
---------
.. (3')
.. corrida con señal de audio limpia y luego filtrada con un pasabajos 


Conclusiónes
------------
.. ¿?
